---
layout: default
title: Introdu√ß√£o a Rust
---

class: middle, center

![ferris](/img/ferris.gif)
# Uma Curta Introdu√ß√£o a Rust

???

* Esse √© o Ferris, nosso mascote n√£o oficial!

---
class: middle, left

## O que vamos cobrir hoje

* O que √© Rust? O que √© cargo? Como configur√°-los?
* Syntax + Conceitos cuja a maior parte √© igual √† outras linguagens
* Syntax + Conceitos particulares ao Rust
* Como continuar a partir daqui

---
class: middle, left

## O que √© Rust?

Rust √© uma linguagem de baixo n√≠vel que roda incrivelmente r√°pida, previne
segfaults e garante seguran√ßa de thread.

--

**Rust √© uma linguagem de baixo n√≠vel que empodera todo mundo a construir software
 confi√°vel e eficiente.**

???

* O que isso significa?
* Perguntar a classe para definir "baixo n√≠vel" e o que eles pensam quando escutam
 isso
* eficiente = t√£o r√°pido quanto C
* confi√°vel = n√£o vai crashar por causa de mem√≥ria mal gerenciada
* Seguran√ßa de mem√≥ria tamb√©m cobre casos de buffer over/underflows

---
class: middle, left

## O que √© cargo Cargo?

* Package manager
* Ferramenta para fazer build
* Rodador de testes
* Gerador de documenta√ß√£o

???

* V√°rias dessas coisas s√£o ferramentas para tornar a vida do usu√°rio mais f√°cil
como rustc e rustdoc.

---
class: middle, left

## Instalando Rust

O Rust inclui Cargo por default.

VOc√™ pode instalar Rust visitando https://rustup.rs.

---
class: middle, left

## Configurando um Projeto

N√≥s vamos criar um projeto *bin√°rio*; a outra op√ß√£o √© criar uma *biblioteca*.

`cargo new` criar√° um esqueleto de configura√ß√£o de um projeto para voc√™.

1. `cd` para um diret√≥rio onde voc√™ queira guardar o c√≥digo
2. `cargo new rustbridge`
3. `cd rustbridge`

Se voc√™ usa uma ferramenta de controle de vers√£o (Git por exemplo), agora √© uma
boa hora pra fazer um commit.

???

Se voc√™ estiver escrevendo uma <strong>biblioteca</strong>, significa que voc√™
pretende que seu c√≥digo seja usado pela aplica√ß√£o de outra pessoa como um crate
ou m√≥dulo.

Se voc√™ est√° escrevendo um <strong>bin√°rio</strong>, significa que voc√™ quer
escrever c√≥digo que pode ser compilado em um bin√°rio que outra pessoa pode
rodar. Se voc√™ quer fazer isso, voc√™ vai precisar usar um `main.rs`. Dentro de
`main.rs` voc√™ tem que ter uma fun√ß√£o main.

---
class: middle, left

## Arquivos criados

- `Cargo.toml`: metadata sobre seu projeto e suas depend√™ncias
- `.gitignore`: ignora arquivos compilados feitos pelo Rust quando adicionados ao Git
- `src/main.rs`: onde seu c√≥digo Rust vai

---
class: middle, left

## `Cargo.toml`

```toml
[package]
name = "rustbridge"
version = "0.1.0"
authors = ["Seu Nome <seunome@voce.com>"]
edition = "2018"

[dependencies]
```

???

* Cargo pegou seu nome do seu env, provavelmente do git.
* Se n√£o estiver l√°, ou se estiver errado, v√° em frente e conserte.

---
class: middle, left

## `src/main.rs`

```rust
fn main() {
    println!("Ol√°, mundo!");
}
```

???

* `fn` come√ßa a defini√ß√£o de uma fun√ß√£o
* `main` √© o mesmo nome da fun√ß√£o
* `main` fn √© especial - o ponto de entrada do seu bin√°rio
* chaves ao redor do corpo da fun√ß√£o
* `println!` √© um macro (n√£o se preocupe) isso imprime na tela
* Fim de linhas com ponto e v√≠rgula (na maior parte do tempo, a gente vai falar
sobre isso mais tarde)

---
class: middle, left

## Rode!

* `cargo run`
* Deve imprimir "Ol√°, mundo!"
* Agora voc√™ tem mais arquivos:
  * diret√≥rio `target`: todas as coisas que foram geradas no build (n√£o ser√£o adicionadas ao Git)
  * `Cargo.lock`: trava suas depend√™ncias (n√≥s n√£o temos nenhuma ainda)
* Tente imprimir outras coisas!
* Tente imprimir duas coisas!

???

* Travar depend√™ncias significa escrever todas as vers√µes em um arquivo autogenerado para que outras pessoas que trabalhem no seu projeto tenham exatamente a mesma vers√£o que voc√™

---
class: middle, left

## Documenta√ß√£o Offline

* V√°rios livros est√£o instalados, `rustup doc -h` para list√°-los
* Procure: procure por uma caixa de busca ou o s√≠mbolo üîç no topo das p√°ginas
* Material e buscas s√£o utiliz√°veis de forma offline

---
class: middle, left

## Documenta√ß√£o da API

https://doc.rust-lang.org/
ou
`rustup doc`

Clique em "Standard Library API Reference"
ou
`rustup doc --std`

`rustup doc --std --path` to show local path

---
class: middle, left

## Syntax + Conceitos cuja a maior parte √© igual √† outras linguagens

---
class: middle, left

## Coment√°rios

* Barra dupla no come√ßo de uma linha (`//`)
* Tente comentar um de suas linhas!
* H√° outros tipos de coment√°rios mas esse √© o mais comum

---
class: middle, left

## Vari√°veis

```rust
let nome = "Ashley";
let idade = 30;
println!("Oi, {}! Voc√™ tem {} anos de idade.", nome, idade);
```

* Tente criar mais vari√°veis e imprimi-las em um √∫nico `println!`

???

* `let`, nome de vari√°vel, um igual, valor, ponto e v√≠rgular.
* Chaves no println, ent√£o valores que deveriam estar l√°

---
class: middle, left

## Experimentando

O que acontece se voc√™ rodar isso:

```rust
let laranjas = 100;
laranjas += 50;
println!("Eu tenho {} laranjas", laranjas);
```

???

* Fazer com que algu√©m leia a mensagem de error
* Aponte que o compilador pegou esse erro pra gente antes do programa rodar

---
class: middle, left

## Mutabilidade

Vari√°veis s√£o *imut√°veis* por padr√£o em Rust.

```rust
let mut laranjas = 100;
laranjas += 50;
println!("I have {} laranjas", laranjas);
```

???

* Rust t√™m influ√™ncias funcionais
* Mudar um valor onde voc√™ n√£o esperava mudar √© uma fonte comum de bugs.

---
class: middle, left

## Tipos

Rust √© fortemente, estaticamente tipada. Tipos comuns fundamentais s√£o:

- `u32`: n√∫mero inteiro de 32 bits unsigned
- `i32`: n√∫mero inteiro de 32 bits signed
- `f64`: n√∫mero de ponto flutuante
- `String` e / ou` & str`: mais sobre isso mais tarde
- `bool`: um booleano

???

* Fortemente tipado significa que seguran√ßa de tipo √© for√ßada. O compilador checa se todos os tipos est√£o corretamente especificados na maior parte das vezes
* Estaticamente tipado significa que os tipos s√£o conhecidos em tempo de compila√ß√£o. Voc√™ n√£o pode ter uma vari√°vel cujo tipo n√£o sabemos
---
class: middle, left

## Infer√™ncia de tipo

* Todo valor tem um tipo que o compilador tem que conhecer.
* Na maior parte do tempo, o compilador consegue adivinhar os tipos.
* Algumas ele n√£o consegue, e voc√™ vai receber um error e precisar√° especificar
o tipo.
* N√≥s poder√≠amos ter escrito `let idade: i32 = 30;`
* Um lugar no qual n√≥s **precisamos** especificar tipos √© nas defini√ß√µes de
fun√ß√µes.

???

* Tipos vem ap√≥s o nome.
* O compilador √© seu amigo! Ele checa se voc√™ tem alguma defini√ß√£o de tipo faltando qual ele n√£o consegue configurar e te fala como consert√°-los

---
class: middle, left

## Fun√ß√µes

```rust
fn add_cinquenta(n: i32) -> i32 {
    n + 50
}

fn main() {
    println!("Lots: {}", add_cinquenta(100));
}
```

???

* Argumento/par√¢metro, nomeado com o tipo especificado
* `->` mais o tipo de retorno, se est√° retornando um valor
* Sem ponto e v√≠rgula na √∫ltima linha quando retornando aquele valor
* Sem a palavra chave `return` a menos que esteja fazendo um retorno antecipado
* Chamadas de fun√ß√£o sempre usam par√™ntesis, mesmo se n√£o tiverem argumentos

---
class: middle, left

## Condicionais: `if`

```rust
fn main() {
    let altura: u32 = 167;
    if altura < 150 {
        println!("Voc√™ √© muito pequeno pra ir na montanha russa.");
    } else if altura > 150 && altura <= 200 {
        println!("Voc√™ pode entrar na montanha russa!");
    } else {
        println!("Voc√™ √© muito alto pra ir na montanha russa.");
    }
}
```
???

* Sem par√™ntesis! Isso n√£o √© opcional
* Atalho para anota√ß√£o de tipo num√©rico
* Idade n√£o pode ser negativo, o compilador vai se certificar que n√£o temos idades negativas

---
class: middle, left

## Condicionais: `match`

Parece com um switch, mas √© melhor.

```rust
fn main() {
    let altura: u32 = 167;
    match altura {
        0..=149 => println!("Voc√™ √© muito pequeno para ir na montanha russa."),
        150..=200 => println!("Voc√™ pode ir na montanha russa!"),
        _ => println!("Voc√™ √© muito alto pra ir na montanha russa."),
    }
}
```

???

* Underscore engloba todos os casos
* Padr√£o, rocket, c√≥digo para executar
* V√≠rgula no final do c√≥digo para rodar
* Se o c√≥digo cont√©m mais de uma linha use chaves para engloba-lo
* Uma v√≠rgula trailing na √∫ltima linha √© o estilo
* E se n√≥s tirarmos a linha com o underscore? Essa √© uma vantagem do `match` sobre `if`/`else if`/`else`

---
class: middle, left

## Arrays

Parecem com arrays em outras linguagens, mas pior.

```rust
let mut cor = [255, 0, 255];
cor[0] = 100;
println!("A cor √© {:?}", cor);
```

???

* Arrays tem um tamanho fixo conhecidos em tempo de compila√ß√£o
* Colchetes, v√≠rgulas
* Indexam para um lugar espec√≠fico
* Precisa de formata√ß√£o de debug no println j√° que o Rust n√£o sabe como voc√™ quer mostrar arrays para os usu√°rios
* Para o dia a dia voc√™ provavelmente n√£o vai precisar de arrays. N√£o muitas pessoas os usam

---
class: middle, left

## Vetores

Na maior parte do tempo, voc√™ provavelmente quer usar um vetor ao inv√©s de um
array.

```rust
let mut precos = vec![30, 100, 2];
precos[0] = 25;
precos.push(40);
println!("Todos os precos s√£o: {:?}", precos);
```

???

* `vec!` √© um macro de atalho, o resto √© exatamente como um array
* Vecs podem mudar de tamanho em tempo de execu√ß√£o
* Ent√£o podemos usar o m√©todo push

---
class: middle, left

## Tangente r√°pida mas √∫til #1: formata√ß√£o do `println!`

* `{}` √© chamado formata√ß√£o de `Display`; apenas em tipos primitivos por padr√£o
* `{:?}` √© chamado formata√ß√£o de `Debug`; mais tipos tem isso por padr√£o
* Display √© para usu√°rios finais, Debug √© para... debugging
* Rust n√£o quer fazer suposi√ß√µes
* Meu favorito: `{:#?}` = debug bonito
* [`fmt` docs](https://doc.rust-lang.org/stable/std/fmt/index.html)

---
class: middle, left

## Tangente r√°pida mas √∫til #2: `panic!`

* Panic para seu programa com uma mensagem.

```rust
fn main() {
    panic!("aaaaa!");
}
```

--
 
O que acontece no √∫ltimo exemplo se n√≥s tentarmos acessar um elemento fora dos limites de um array?

```rust
let cor = [255, 0, 255];
let index = 9;
println!("O d√©cimo elementto √© {:?}", cor[index]);
```

???

* √â um `panic!` por baixo dos panos!
* Isso est√° relacionado com seguran√ßa-- n√£o continue com dados ruins!


---
class: middle, left

## Looping (e ranges)

* `for` loops s√£o muito comuns:

```rust
for i in 0..10 {
    println!("N√∫mero {}", i);
}
```

```rust
let nomes = vec!["Carol", "Jake", "Marylou", "Bruce"];
for nome in nomes.iter() {
    println!("Hi {}!", nome);
}
```

* Novamente, sem par√™nteses
* `loop` cria um loop infinito
* `while` loops executam enquanto sua condi√ß√£o √© verdadeira
* `break` sai do loop atual

???

* O loop `for` significa que voc√™ nunca passar√° do fim de um array
* O que √© um iter? √â um tipo compartilhado para coisas que podem ser iteradas, muitos outros tipos podem ser transformados em iters

---
class: middle, left

## Iteradores

```rust
for i in (0..10).filter(|x| x % 2 == 0) {
    println!("i = {}", i);
}

for i in (0..10).map(|x| x * x ) {
    println!("i = {}", i);
}

let sum = (0..10).fold(0, |acc, x| acc + x);
println!("sum = {}", sum);
```

* Veja [Iterator docs](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html) para mais divers√£o com iterators.
* O `|x| x % 2 == 0` no exemplo √© uma closure, elas podem ser usadas em outras situa√ß√µes tamb√©m.

???

* Uma closure tamb√©m √© conhecida como uma lambda, ou uma fun√ß√£o an√¥nima. √â basicamente uma fun√ß√£o que n√£o est√° ligada a uma vari√°vel.

---
class: middle, left

## Enums

* Combinam bem com `match`

```rust
enum Semaforo {
    Vermelho,
    Amarelo,
    Verde,
}
let luz = Semaforo::Verde;

match luz {
    Semaforo::Vermelho => println!("PARE!"),
    Semaforo::Amarelo => println!("Devagar!"),
    Semaforo::Verde => println!("Vai vai vai!"),
}
```

???

* namespacing √© dois dois pontos
* Mostre avisos!

---
class: middle, left

## Enums

* Melhor que outras linguagens, podem conter valores!

```rust
enum TipoJogo {
    SinglePlayer,
    MultiPlayer(u32),
}

let jogo = TipoJogo::MultiPlayer(4);

match jogo {
    TipoJogo::SinglePlayer => println!("Que tal paci√™ncia?"),
    TipoJogo::MultiPlayer(2) => println!("Que tal damas?"),
    TipoJogo::MultiPlayer(4) => println!("Que tal bridge?"),
    TipoJogo::MultiPlayer(num) => println!("Que tal um jogo de {}-jogadores?", num),
}
```

???

* Valores s√£o espec√≠ficos para cada variante
* √â necess√°rio definir o tipo dos valores nas variantes
* Destructure = padr√µes que est√£o ligados √†s partes
* Destructure para tirar valores

---
class: middle, left

## Testes

```rust
#[derive(PartialEq, Debug)] // necess√°rio para comparar valores de enum
enum Semaforo {
    Vermelho,
    Amarelo,
    Verde,
}

#[test]
fn new_person_setup() {
    let luz = Semaforo::Amarelo;

    assert!(luz == Semaforo::Amarelo);
    assert_eq!(luz, Semaforo::Amarelo);

    assert_ne!(luz, Semaforo::Vermelho);
}
```

- Run with `cargo test`

???

- Testes s√£o apenas fun√ß√µes normais que fazem assertions, pequenos testes que checam (na maior parte das vezes) se alguma coisa √© igual a outra coisa
- Ordem n√£o importa nos argumentos de assert_eq/assert_ne
- Tente escrever um teste que vai falhar e veja como a mensagem de erro se parece

---
class: middle, left

## Ignorando testes

```rust
#[test]
#[ignore]
fn nao_implementado_ainda() {
    assert_eq!(true, false);
}
```

Para rodar testes ignorados de qualquer jeito: `cargo test -- --ignored`

???

- Testes ainda tem que compilar, mas n√£o precisam passar

---
class: middle, left

## Pausa de Rustlings!

- [github.com/rust-lang/rustlings](https://github.com/rust-lang/rustlings)
- Instru√ß√µes no Readme, pergunte se algo n√£o for claro para voc√™

???

---
class: middle, left

## Sintaxe + Conceitos particulares do Rust

---
class: middle, left

## Op√ß√£o

**Rust n√£o tem `nil`/`null`** ent√£o para expressar que um valor pode ser algo ou nada, Rust tem o tipo `Option`.

Option √© um enum fornecido pela biblioteca padr√£o:

```rust
enum Option<T> {
    Some(T),
    None
}
```

???

* T √© um par√¢metro de tipo gen√©rico, significa que pode conter qualquer itpo
* N√£o existem mais m√©todos indefinidos no nil!!!!

---
class: middle, left

## Usando Option

```rust
let mut instrutores = vec!["Carol"];

let a = instrutores.pop();
println!("a √© {:?}", a);

let b = instrutores.pop();
println!("b √© {:?}", b);
```

**Esse c√≥digo √© seguro?**

???

* Quando retiramos o √∫ltimo elemento do vetor, talvez n√£o exista um elemento para ser retirado!

---
class: middle, left

## Usando Option

```rust
let a = Some("Carol");

let nome = a.expect("Nenhum nome presente");
println!("Nome tem {} bytes", nome.len());
```

???

* N√£o se pode chamar `len` em um `Option` diretamente, j√° que ele pode ser `None`!
* expect entra em a√ß√£o se receber um None, bom para prototipar ou quando voc√™ REALMENTE tem CERTEZA que voc√™ tem Some
    * Coloque uma mensagem de erro em expect que vai te ajudar a debugar
    * Tente mudar `a` para ver o que acontece
        `let a: Option<&str> = None;`
    * Mencione gloss sobre anota√ß√£o de tipo

---
class: middle, left

## Usando Option

```rust
let b: Option<&str> = Some("Carol");

match b {
    Some(nome) => println!("Outro nome tem {} bytes", nome.len()),
    None => println!("Nenhum nome!"),
}
```

???

* Match √© √∫til para lidar com ambos os casos
* Option √© s√≥ mais um enum!

---
class: middle, left

## Result

* Outro enum da biblioteca padr√£o
* Para quando algo pode dar certo ou errado
* Rust n√£o tem exce√ß√µes; usar `Result` √© como voc√™ lida com erros.

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

???

---
class: middle, left

## Usando Result

```rust
let numstr = "6";
let num = numstr.parse::<i32>();
println!("num = {:?}", num);

let numstr = "florp";
let num = numstr.parse::<i32>();
println!("num = {:?}", num);
```

???

* Turbofish! Porque n√≥s poder√≠amos usar o parse em muitos tipos diferentes.

---
class: middle, left

## Usando Result

```rust
let numstr = "6";
let num = numstr.parse::<i32>();
let num = num.expect("deveria ter um n√∫mero");

println!("num + 5 = {}", num + 5);
```

---
class: middle, left

## Usando Result

```rust
let numstr = "florp";
let num = numstr.parse::<i32>();

let resposta = match num {
    Ok(n) => n + 5,
    Err(_) => 0,
};
println!("Resposta √© {}", resposta);
```

???

* Sim, pode parecer chato ser for√ßada a pensar sobre casos de falha o tempo todo
* Mas vai salvar tempo de debugging mais tarde, confia em mim
* H√° muitos m√©todos em Option e Result para a lidar com formas comuns de us√°-los

---
class: middle, left

## Operador `?` para propagar erros para cima

* S√≥ pode ser usado em m√©todos/fun√ß√µes que retornam `Result`!!!!

```rust
fn add_five_to_string(s: String) ->
    Result<i32, std::num::ParseIntError> {

    let resposta = s.parse::<i32>()? + 5;
    Ok(resposta)
}
```

???

* √â comum ter v√°rias fun√ß√µes que retornam `Result` ent√£o tenha um match na camada mais exterior
* Chegando em algum dia: a habilidade de usar `?` em `Option` e outros tipos, em fns que n√£o retornam `Result`

---
class: middle, left

## Strings: AVISO

* Strings em Rust parecem complicadas
* N√≥s sentimos muitos

???

Trabalhar com strings em Rust √© mais complicado do que trabalhar com strings em outras linguagens.

Strings s√£o, na verdade, complicadas em todas as linguagens, elas s√≥ escondem a complexidade de voc√™ e fazem escolhas por voc√™. Rust faz com que voc√™ tenha que ser expl√≠cito com suas escolhas.

---
class: middle, left

## Dois tipos de strings

### `String`

* Alocada
* Aument√°vel (voc√™ pode fazer append nela)
* Podem ser criadas com:
  * `algumacoisa.to_string()`
  * `String::from("conte√∫do da string")`

### `&str`

* Pronunciado como "string slice"
* Dados da string guardados em outro lugar
* Hardcoded strings s√£o `&str`s

???

* `String` √© meio que como um `Vec`

---
class: middle, left

## Um problema comum

```rust
fn fizz(num: u32) -> String {
    if num % 3 == 0 {
        "Fizz"
    } else {
        num.to_string()
    }
}
```

???

* "Fizz" n√£o √© uma String √© um &str
* Necess√°rio fazer de Fizz uma string para consertar isso

---
class: middle, left

## String Slices

```rust
let s = String::from("Me chame de Ishmael bl√° bl√°...");
let parte = &s[0..4];

println!("parte √© '{}'", parte);
```

???

* Vec<T> : &[T] :: String : &str
* Com string slices, √≠ndices s√£o bytes, n√£o chars, longa hist√≥ria

---
class: middle, left

## Ownership

* O *owner* de alguma coisa √© o respons√°vel por limp√°-la.
* Quando owners saem de escopo, o Rust √© automaticamente chamado para limpar o c√≥digo.

```rust
fn main() {
    let v = vec![1, 2, 3];
    println!("v √© v√°lido aqui! {:?}", v);
}

// v n√£o √© mais v√°lido!
```

???

* Aponte onde s √© v√°lido e onde s sai de escopo

---
class: middle, left

## Transferindo Ownership

* Quando voc√™ passa um argumento para uma fun√ß√£o, a posse √© transferida para a fun√ß√£o.
* N√≥s dizemos que algo √© *movido*.

```rust
fn main() {
    let v = vec![1, 2, 3];
    print_vec(v);
    print_vec(v);
}

fn print_vec(v: Vec<i32>) {
    println!("v √© {:?}", v);
}
```

???

* Explicar a mensagem de erro.
* Sim isso √© estranho e chato!
* N√£o se preocupe, n√≥s vamos consetar!

---
class: middle, left

## Refer√™ncias

* Deixam voc√™ pegar emprestado um recurso do qual voc√™ n√£o √© propriet√°ria
* A refer√™ncia s√≥ √© v√°lida de se a propriet√°ria √© v√°lida. Rust se certificar que voc√™ n√£o est√° usando uma refer√™ncia inv√°lida *em tempo de compila√ß√£o*.

```rust
fn main() {
    let v = vec![1, 2, 3];
    print_vec(&v);
    print_vec(&v);
}

fn print_vec(v: &Vec<i32>) {
    println!("v √© {:?}", v);
}
```

???

- Ent√£o a menos que voc√™ *queira* que sua fun√ß√£o receba o controle ou a se torne a propriet√°ria de um argumento, voc√™ *provavelmente* far√° com que a maior parte das suas fun√ß√µes recebam refer√™ncias como argumentos.

---
class: middle, left

## Refer√™ncias mut√°veis

* Assim como vari√°veis, refer√™ncias s√£o imut√°veis por padr√£o, mas voc√™ pode torn√°-las mut√°veis com `mut`.
* Voc√™ pode ter muitas refer√™ncias imut√°veis em um escopo
* Voc√™ s√≥ pode ter uma refer√™ncia mut√°vel e nenhuma refer√™ncia imut√°vel em um escopo

```rust
fn main() {
    let mut v = vec![1, 2, 3];
    change_vec(&mut v);
    change_vec(&mut v);
    println!("v √© {:?}", v);
}

fn change_vec(v: &mut Vec<i32>) {
    v[0] *= 5;
}
```

???

* Esse √© o jeito como voc√™ faria uma fun√ß√£o que permite ter seus argumentos modificados.

---
class: middle, left

## N√£o √© permitido term refer√™ncias mut√°veis e imut√°veis no mesmo escopo.

```rust
fn main() {
    let mut v = vec![1, 2, 3];

    let f = &v[0];
    v.clear();

    println!("O que f seria? {}", f);
}
```

???

* Isso n√£o vai compilar-- olhe o erro.
* Onde est√° a refer√™ncia imut√°vel?
* Onde est√° a refer√™ncia mut√°vel?
* Outras linguagens v√£o deixar voc√™ fazer isso e te dar dados que s√£o inv√°lidos.
* Vulnerabilidades de seguran√ßa!

---
class: middle, left

## Como continuar a partir daqui
### Sintaxe + conceitos que n√£o cobrimos mas s√£o coisas relevantes

.pull-left[
* Lifetimes(Tempos de vida)
* Tuples(Tuplas)
* Structs(Estruturas)
* Methods(M√©todos)
* `if let`
]
.pull-right[
* FFI
* Traits(Tra√ßos)
* Generics(Gen√©ricos)
* Macros
* Threads
* Composition over inheritance(Composi√ß√£o sobre heran√ßa)
]

---
class: middle, left

## Resources

* [The Rust Programming Language Book (Ingl√™s)](https://doc.rust-lang.org/stable/book/)
* [O Livro da Linguagem de Programa√ß√£o Rust (Portugu√™s)](https://github.com/rust-br/rust-book-pt-br)
* [Rust by Example](http://rustbyexample.com/)
* [Rust learning](https://github.com/ctjhoa/rust-learning/)
* [into_rust() screencasts](http://intorust.com/)

---
class: middle, left

## S√≥ mais uma coisa: Crates

![cratesio](/img/cratesio.png)

???

* Como se fosse rubygems.org, npmjs.com
* F√°cil de adicionar crates (bibliotecas) no seu projeto
* A stdlib de Rust √© pequena e est√°vel
* Crates podem mudar mais r√°pido e mais radicalmente independente de Rust
* N√≥s vamos usar alguns crates no nosso projeto!
