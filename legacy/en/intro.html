---
layout: default
title: Intro to Rust
---

class: middle, center

![ferris](/img/ferris.gif)
# A Very Brief Intro to Rust

???

* This is Ferris, our unofficial mascot!

---
class: middle, left

## Overview

* What is Rust? What is Cargo? How to set them up?
* Syntax + Concepts mostly the same as other languages
* Syntax + Concepts particular to Rust
* Further learning

---
class: middle, left

## What is Rust?

Rust is a systems programming language that runs blazingly fast, prevents
segfaults, and guarantees thread safety.

--

**Rust is a systems programming language that empowers everyone to build
reliable and efficient software.**

???

* What does any of this mean?
* Ask class to define "systems programming", what do they think of when they hear it
* efficient = as fast as C
* reliable = won't crash because of mismanaged memory
* Memory safety also covers buffer over/underflows

---
class: middle, left

## What is Cargo?

* Package manager
* Build tool
* Test runner
* Documentation generator

???

* A lot of these things are convenience wrappers around other tools like rustc
and rustdoc.

---
class: middle, left

## Installing Rust

Rust includes Cargo by default.

You can install Rust by visiting https://rustup.rs.

---
class: middle, left

## Setting up a Project

We're going to be making a *binary* project; the other option is a *library*.

`cargo new` will create a skeleton project setup for you.

1. `cd` to a directory where you like to store code
2. `cargo new rustbridge`
3. `cd rustbridge`

If you use version control (Git for example), now would be a good time to commit.

???

If you are writing a <strong>library</strong>, it means you intend for your
code to be used in someone else's application as a crate or module.

If you are writing a <strong>binary</strong>, it means that you'd like
to write code that compiles into a binary that someone can run. If you
want to do this, you need to use a `main.rs`. Inside the `main.rs` you
should have a `main` function.

---
class: middle, left

## Files created

- `Cargo.toml`: metadata about your project and its dependencies
- `.gitignore`: ignores compiled files built by Rust when adding them to Git
- `src/main.rs`: where your Rust code goes

---
class: middle, left

## `Cargo.toml`

```toml
[package]
name = "rustbridge"
version = "0.1.0"
authors = ["Your Name <yourname@you.com>"]
edition = "2018"

[dependencies]
```

???

* Cargo got your name from your env, probably from git.
* If it's not there, or if it's wrong, go ahead and fix it.

---
class: middle, left

## `src/main.rs`

```rust
fn main() {
    println!("Hello, world!");
}
```

???

* `fn` starts a function definition
* `main` is the name of the function
* `main` fn is special - entry point of your binary
* curly braces around the body
* `println!` is a macro (don't worry) that prints to the screen
* End lines with semicolons (mostly, we'll talk later)

---
class: middle, left

## Run it!

* `cargo run`
* Should print "Hello, world!"
* Now you have more files:
  * `target` directory: all the built stuff (won't be added to Git)
  * `Cargo.lock`: locks your dependencies (we don't have any yet)
* Try printing out something else!
* Try printing out two things!

???

* Locking dependencies means writing down all of the versions into an autogenerated file so that other people that work on your project get the exact same versions
---
class: middle, left

## Offline Documentation

* Several books are installed, `rustup doc -h` to list them
* Search: look for search box or 🔍 symbol at top of pages
* Material and search are usable offline

---
class: middle, left

## API Documentation

https://doc.rust-lang.org/
or
`rustup doc`

Click on "Standard Library API Reference"
or
`rustup doc --std`

`rustup doc --std --path` to show local path

---
class: middle, left

## Syntax + Concepts mostly the same as other languages

---
class: middle, left

## Comments

* Double slash at the beginning of a line (`//`)
* Try commenting out one of your lines printing!
* There are other kinds of comments but this is the most common

---
class: middle, left

## Variables

```rust
let name = "Ashley";
let age = 30;
println!("Hi, {}! You are {} years old.", name, age);
```

* Try making more variables and printing them all out in one `println!`

???

* `let`, variable name, single equals, value, semicolon.
* Crab pincers in println, then values that should fit in there

---
class: middle, left

## Experiment

What happens if you run this:

```rust
let apples = 100;
apples += 50;
println!("I have {} apples", apples);
```

???

* Have someone read the error message
* Point out that the compiler caught this for us before the program ran 

---
class: middle, left

## Mutability

Variables are *immutable* by default in Rust.

```rust
let mut apples = 100;
apples += 50;
println!("I have {} apples", apples);
```

???

* Rust has functional influences
* Changing a value where you didn't expect to is a common source of bugs.

---
class: middle, left

## Types

Rust is strongly, statically typed. Common fundamental types are:

- `u32`: unsigned 32-bit integer
- `i32`: signed 32-bit integer
- `f64`: floating point number
- `String` and/or `&str`: more on these later
- `bool`: a boolean

???

* Strongly typed means that type safety is enforced more strongly. The compiler checks whether all types are correctly specified most of the time
* Statically typed means that types are known at compile time. You can't have a variable whose type we don't know  
---
class: middle, left

## Type inference

* Every value has a type that the compiler has to know about.
* Most of the time, the compiler can figure it out.
* Sometimes it can't, and you'll get an error and need to add an annotation.
* We could have written `let age: i32 = 30;`
* A place we **must** specify types is function definitions.

???

* Types come after the name
* The compiler is your friend! It checks whether you have any missing type annotations that it can't figure out and tells you how to fix them

---
class: middle, left

## Functions

```rust
fn add_fifty(n: i32) -> i32 {
    n + 50
}

fn main() {
    println!("Lots: {}", add_fifty(100));
}
```

???

* Argument/parameter, named with type specified
* `->` plus return type, if returning a value
* No semicolon on the last line when returning that value
* No `return` keyword unless doing an early return
* Function call always uses parens, even if no arguments

---
class: middle, left

## Conditionals: `if`

```rust
fn main() {
    let height: u32 = 167;
    if height < 150 {
        println!("You're too small to go on the rollercoaster.");
    } else if height > 150 && height <= 200 {
        println!("You may go on the rollercoaster!");
    } else {
        println!("You're too tall to go on the rollercoaster.");
    }
}
```
???

* No parens! This is not optional
* Shorthand for numeric type annotation
* Age can't be negative, compiler will make sure we don't have negative ages

---
class: middle, left

## Conditionals: `match`

Kinda like a switch. But better.

```rust
fn main() {
    let height: u32 = 167;
    match height {
        0..=149 => println!("You're too small to go on the rollercoaster."),
        150..=200 => println!("You may go on the rollercoaster!"),
        _ => println!("You're too tall to go on the rollercoaster."),
    }
}
```

???

* Underscore is catch-all
* Pattern, rocket, code to run
* Commas at the end of the code to run
* If the code is more than one line, surround with curly braces
* Trailing comma on the last one is the style
* What if we take out the line with the underscore? This is advantage to `match` over `if`/`else if`/`else`

---
class: middle, left

## Arrays

Kinda like arrays in other languages, but worse.

```rust
let mut color = [255, 0, 255];
color[0] = 100;
println!("The color is {:?}", color);
```

???

* Arrays are a fixed size known at compile time
* Square brackets, commas
* Indexing to a particular location
* Need debug formatting in println since Rust doesn't know how you want to display arrays to your users
* For day-to-day usage, you probably won't need arrays. Not many people use them

---
class: middle, left

## Vectors

Most of the time, you probably want a vector rather than array.

```rust
let mut prices = vec![30, 100, 2];
prices[0] = 25;
prices.push(40);
println!("All the prices are: {:?}", prices);
```

???

* `vec!` shorthand macro, the rest is like an array
* Vecs can change in size at runtime
* So we can call the `push` method

---
class: middle, left

## Quick but Useful Tangent #1: `println!` formatting

* `{}` is called `Display` formatting; only on primitive types by default
* `{:?}` is called `Debug` formatting; more types have this by default
* Display is for end users, Debug is for... debugging
* Rust doesn't want to make assumptions
* My favorite: `{:#?}` = pretty debug
* [`fmt` docs](https://doc.rust-lang.org/stable/std/fmt/index.html)

---
class: middle, left

## Quick but Useful Tangent #2: `panic!`

* Panic stops your program with a message.

```rust
fn main() {
    panic!("aaaaa!");
}
```

--
  
What happens in the last example if we try to access an element out of bounds of the array?

```rust
let color = [255, 0, 255];
let index = 9;
println!("The 10th element is {:?}", color[index]);
```

???

* It's a `panic!` behind the scenes!
* This has to do with safety-- don't continue with bad data!


---
class: middle, left

## Looping (and ranges)

* `for` loops are most common:

```rust
for i in 0..10 {
    println!("Number {}", i);
}
```

```rust
let names = vec!["Carol", "Jake", "Marylou", "Bruce"];
for name in names.iter() {
    println!("Hi {}!", name);
}
```

* Again, no parens
* `loop` creates an infinite loop
* `while` loops run while their condition is true
* `break` exits the current loop

???

* `for` loop means you never go past the end of the array
* What is iter? It's a shared type for stuff that can get iterated over, many other types can be transformed into it

---
class: middle, left

## Iterators

```rust
for i in (0..10).filter(|x| x % 2 == 0) {
    println!("i = {}", i);
}

for i in (0..10).map(|x| x * x ) {
    println!("i = {}", i);
}

let sum = (0..10).fold(0, |acc, x| acc + x);
println!("sum = {}", sum);
```

* See the [Iterator docs](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html) for lots more fun stuff.
* The `|x| x % 2 == 0` in the examples is a closure, they can be used in other situations too.

???

* A closure is also known as a lambda, or anonymous function. It's basically a function that's not bound to a variable.
---
class: middle, left

## Enums

* Nice to use with `match`

```rust
enum TrafficLight {
    Red,
    Yellow,
    Green,
}
let light = TrafficLight::Green;

match light {
    TrafficLight::Red => println!("STOP!"),
    TrafficLight::Yellow => println!("Slow down!"),
    TrafficLight::Green => println!("Go go go!"),
}
```

???

* Double colon is namespacing
* Show warnings!

---
class: middle, left

## Enums

* Better than in other languages: can hold values!

```rust
enum GameType {
    SinglePlayer,
    MultiPlayer(u32),
}

let game = GameType::MultiPlayer(4);

match game {
    GameType::SinglePlayer => println!("How about solitaire?"),
    GameType::MultiPlayer(2) => println!("How about checkers?"),
    GameType::MultiPlayer(4) => println!("How about bridge?"),
    GameType::MultiPlayer(num) => println!("How about {}-player tag?", num),
}
```

???

* Values are specific to each variant
* Have to define the type of the values in the variant
* Destructure = patterns that bind to parts
* Destructure to get values out

---
class: middle, left

## Tests

```rust
#[derive(PartialEq, Debug)] // necessary to compare enum values
enum TrafficLight {
    Red,
    Yellow,
    Green,
}

#[test]
fn new_person_setup() {
    let light = TrafficLight::Yellow;

    assert!(light == TrafficLight::Yellow);
    assert_eq!(light, TrafficLight::Yellow);

    assert_ne!(light, TrafficLight::Red);
}
```

- Run with `cargo test`

???

- Tests are just normal functions that perform assertions, small checks that check (mostly) for if something is equal to something else
- Order doesn't matter in the arguments to assert_eq/assert_ne
- Try writing a test that will fail and see what the failure message looks like

---
class: middle, left

## Ignoring tests

```rust
#[test]
#[ignore]
fn not_implemented_yet() {
    assert_eq!(true, false);
}
```

To run ignored tests anyway: `cargo test -- --ignored`

???

- Test still has to compile, but doesn't have to pass

---
class: middle, left

## Rustlings break!

- [github.com/rust-lang/rustlings](https://github.com/rust-lang/rustlings)
- Instructions in the Readme, ask if there's anything unclear

???

---
class: middle, left

## Syntax + Concepts particular to Rust

---
class: middle, left

## Option

**Rust doesn't have `nil`/`null`** so to express that a value might be something or nothing, Rust has the `Option` type.

Option is an enum provided by the standard library:

```rust
enum Option<T> {
    Some(T),
    None
}
```

???

* T is a generic type parameter, means Some can hold any type
* No more undefined method on nil!!!!

---
class: middle, left

## Using Option

```rust
let mut instructors = vec!["Carol"];

let a = instructors.pop();
println!("a is {:?}", a);

let b = instructors.pop();
println!("b is {:?}", b);
```

**Is this code safe?**

???

* When we pop off the last element of a vec, there might not be one!

---
class: middle, left

## Using Option

```rust
let a = Some("Carol");

let name = a.expect("No name present");
println!("Name is {} bytes long", name.len());
```

???

* Can't call `len` on an `Option` directly since it could be `None`!
* expect panics if it gets a None, good for prototyping or when you're REALLY REALLY SURE you have Some
    * Set an error message in expect that is useful to you for debugging
    * Try changing `a` to this and see what happens
        `let a: Option<&str> = None;`
    * Mention but gloss over type annotation

---
class: middle, left

## Using Option

```rust
let b: Option<&str> = Some("Carol");

match b {
    Some(name) => println!("Other name is {} bytes long", name.len()),
    None => println!("No name!"),
}
```

???

* Match is useful for handling both cases
* Option is just another enum!

---
class: middle, left

## Result

* Another enum in the standard library
* For when something could succeed or fail
* Rust doesn't have exceptions; using `Result` is how you handle errors.

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

???

---
class: middle, left

## Using Result

```rust
let numstr = "6";
let num = numstr.parse::<i32>();
println!("num = {:?}", num);

let numstr = "florp";
let num = numstr.parse::<i32>();
println!("num = {:?}", num);
```

???

* Turbofish! Because we could parse into many different types.

---
class: middle, left

## Using Result

```rust
let numstr = "6";
let num = numstr.parse::<i32>();
let num = num.expect("should have a number");

println!("num + 5 = {}", num + 5);
```

---
class: middle, left

## Using Result

```rust
let numstr = "florp";
let num = numstr.parse::<i32>();

let answer = match num {
    Ok(n) => n + 5,
    Err(_) => 0,
};
println!("Answer is {}", answer);
```

???

* Yes, this might feel annoying to be forced to think about failure cases all the time
* But it will save debugging time later, trust me
* There are lots of methods on Option and Result to help with common ways of handling them

---
class: middle, left

## `?` operator to propagate errors up

* Can only be used in methods/functions that return `Result`!!!!

```rust
fn add_five_to_string(s: String) ->
    Result<i32, std::num::ParseIntError> {

    let answer = s.parse::<i32>()? + 5;
    Ok(answer)
}
```

???

* Typical to have lots of functions that return `Result` then have a `match` at the outer layer
* Coming someday: ability to use `?` on `Option` and other types, in fns that don't return `Result`

---
class: middle, left

## Strings: WARNING

* Strings in Rust feel complicated
* We're sorry

???

Working with strings in Rust is more complicated than working with strings in other languages.

Strings are actually complicated in all languages, it's just that most hide the complexity from you and make choices for you. Rust makes you be explicit with the choices.

---
class: middle, left

## Two string types

### `String`

* Allocated
* Growable (you can append stuff to them)
* Can create with either:
  * `something.to_string()`
  * `String::from("string content")`

### `&str`

* Pronounced "string slice"
* View into string data stored somewhere else
* Hardcoded strings are `&str`s

???

* `String` is kinda like `Vec`

---
class: middle, left

## A common problem

```rust
fn fizz(num: u32) -> String {
    if num % 3 == 0 {
        "Fizz"
    } else {
        num.to_string()
    }
}
```

???

* "Fizz" here isn't a String, it's a &str
* Have to make Fizz a String to fix this

---
class: middle, left

## String Slices

```rust
let s = String::from("Call me Ishmael blah blah...");
let part = &s[0..4];

println!("part is '{}'", part);
```

???

* Vec<T> : &[T] :: String : &str
* With string slices, indices are bytes, not chars, long story

---
class: middle, left

## Ownership

* The *owner* of something is who is responsible for cleaning it up.
* When owners go out of scope, Rust automatically calls the cleanup code.

```rust
fn main() {
    let v = vec![1, 2, 3];
    println!("v is valid here! {:?}", v);
}

// v is not valid here anymore!
```

???

* Point to where s is valid and where s goes out of scope

---
class: middle, left

## Transferring Ownership

* When you pass an argument to a function, ownership is transferred to the function.
* We say that something is *moved*.

```rust
fn main() {
    let v = vec![1, 2, 3];
    print_vec(v);
    print_vec(v);
}

fn print_vec(v: Vec<i32>) {
    println!("v is {:?}", v);
}
```

???

* Explain error message
* Yes this is weird and annoying!
* Don't worry we'll fix it!

---
class: middle, left

## References

* Let you borrow a resource you don't own
* A reference is only valid as long as the owner is valid. Rust ensures you aren't using an invalid reference *at compile time*.

```rust
fn main() {
    let v = vec![1, 2, 3];
    print_vec(&v);
    print_vec(&v);
}

fn print_vec(v: &Vec<i32>) {
    println!("v is {:?}", v);
}
```

???

- So unless you *want* your function to take ownership of an argument, you *probably* will have most of your functions take references as arguments.

---
class: middle, left

## Mutable References

* Like variables, references are immutable by default, but you can make them mutable with `mut`.
* You may have many immutable references in a scope
* You may only have one mutable reference and no immutable references in a scope

```rust
fn main() {
    let mut v = vec![1, 2, 3];
    change_vec(&mut v);
    change_vec(&mut v);
    println!("v is {:?}", v);
}

fn change_vec(v: &mut Vec<i32>) {
    v[0] *= 5;
}
```

???

* This is how you would make a function that's allowed to change its arguments.

---
class: middle, left

## Not allowed to have mutable and immutable references in the same scope.

```rust
fn main() {
    let mut v = vec![1, 2, 3];

    let f = &v[0];
    v.clear();

    println!("What would f be? {}", f);
}
```

???

* This won't compile-- look at the error.
* Where is the immutable reference?
* Where is the mutable reference?
* Other languages will let you do this and give you invalid data.
* Security vulnerabilities!

---
class: middle, left

## Further learning
### Syntax + Concepts we didn't cover but that are things

.pull-left[
* Lifetimes
* Tuples
* Structs
* Methods
* `if let`
]
.pull-right[
* FFI
* Traits
* Generics
* Macros
* Threads
* Composition over inheritance
]

---
class: middle, left

## Resources

* [The Rust Programming Language Book](https://doc.rust-lang.org/stable/book/)
* [Rust by Example](http://rustbyexample.com/)
* [Rust learning](https://github.com/ctjhoa/rust-learning/)
* [into_rust() screencasts](http://intorust.com/)

---
class: middle, left

## Just One More Thing: Crates

![cratesio](/img/cratesio.png)

???

* Like rubygems.org, npmjs.com
* Easy to add crates (libraries) to your project
* Rust's stdlib is small and stable
* Crates can change more rapidly and more radically independently of Rust
* We're going to be using some crates for our project!
