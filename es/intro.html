---
layout: default
title: Introducci√≥n a Rust
---

class: middle, center

![ferris](/img/ferris.gif)
# Una Breve Introducci√≥n a Rust

???

* ¬°Este es Ferris, nuestra mascota no oficial!

---
class: middle, left

## Informaci√≥n general

* ¬øQu√© es Rust? ¬øQu√© es Cargo? ¬øC√≥mo configurarlas?
* Sintaxis + Conceptos en su mayor√≠a comunes con otros lenguajes
* Sintaxis + Conceptos particulares a Rust
* Aprendizaje adicional

---
class: middle, left

## ¬øQu√© es Rust?

Rust es un lenguaje de programaci√≥n de sistemas que se ejecuta incre√≠blemente r√°pido, previene
fallas de seguridad, y garantiza la seguridad entre subprocesos.

--

**Rust es un lenguage de programaci√≥n de sistemas que permite a todos a construir
software confiable y eficiente.**

???

* ¬øQu√© significa esto?
* Pida a la clase que defina "programaci√≥n de sistemas", qu√© piensan cuando escuchan eso
* eficiente = tan r√°pido como C
* confiable = no se colgar√° por la mala gesti√≥n de memoria
* Seguridad de memoria tambi√©n cubre desbordamientos (overflow / underflow)

---
class: middle, left

## ¬øQu√© es Cargo?

* Gestor de paquetes
* Herramienta de construcci√≥n
* Ejecutor de pruebas
* Generador de documentaci√≥n

???

* Muchas de estas cosas son envoltorios de conveniencia sobre otras herramientas como rustc
y rustdoc.

---
class: middle, left

## Instalando Rust

Rust incluye Cargo por defecto.

Puedes instalar Rust visitando https://rustup.rs.

---
class: middle, left

## Configurando un Proyecto

Vamos a hacer un proyecto *binario*; la otra opci√≥n es una *liber√≠a*.

`cargo new` crear√° una estructura esqueleto del proyecto para ti.

1. `cd` al directorio en donde te gustar√≠a almacenar el c√≥digo
2. `cargo new rustbridge`
3. `cd rustbridge`

Si usas control de versiones (Git, por ejemplo), ahora es un buen momento para hacer commit.

???

Si est√°s escribiendo una <strong>librer√≠a</strong>, significa que tienes la intenci√≥n que tu
c√≥digo sea usado en la aplicaci√≥n de alguien m√°s como un crate o m√≥dulo.

Si est√°s escribieindo un <strong>binario</strong>, significa que te gustar√≠a
escribir c√≥digo que compile en un binario que alguien pueda ejecutar. Si quieres
hacer esto, necesitas usar un `main.rs`. Dentro del `main.rs` deber√≠as
tener una funci√≥n `main`.

---
class: middle, left

## Archivos creados

- `Cargo.toml`: Metadatos sobre tu proyecto y sus dependencias
- `.gitignore`: Ignora los archivos compilados construidos por Rust al agregarlos a Git
- `src/main.rs`: Donde ir√° tu c√≥digo Rust

---
class: middle, left

## `Cargo.toml`

```toml
[package]
name = "rustbridge"
version = "0.1.0"
authors = ["Your Name <yourname@you.com>"]

[dependencies]
```

???

* Cargo obtiene tu nombre desde tu entorno, probablemente desde git.
* Si no est√° ah√≠, o si est√° mal, adelante, corr√≠gelo.

---
class: middle, left

## `src/main.rs`

```rust
fn main() {
    println!("Hello, world!");
}
```

???

* `fn` empieza una definici√≥n de funci√≥n
* `main` es el nombre de la funci√≥n
* `fn main` es el punto de entrada especial de tu binario
* llaves al rededor del cuerpo
* `println!` es una macro (no te preocupes). Esto imprime en la pantalla
* Las l√≠neas termina con puntos y comas (la mayor√≠a, ya lo veremos despu√©s)

---
class: middle, left

## ¬°Ejecutarlo!

* `cargo run`
* Deber√≠a imprimir "Hello, world!"
* Ahora tienes m√°s archivos:
  * directorio `target`: Todos las cosas construidas (no hay que agregarlos a Git)
  * `Cargo.lock`: Bloquea tus dependencias (a√∫n no tenemos)
* ¬°Intenta imprimir algo m√°s!
* ¬°Intenta imprimir dos cosas!

???

* Bloquear las dependencias significa anotar todas las versiones en un archivo generado autom√°ticamente para que las otras personas que trabajan en tu proyecto tengan exactamente las mismas versiones
---
class: middle, left

## Documentaci√≥n sin conexi√≥n

* Varios manuales estan incluidos, `rustup doc -h` para listarlos
* Busqueda: al inicio de cada pagina hay un campo de busqueda o este simbolo üîç
* Todo el material y la busqueda estan disponibles sin conexion

---
class: middle, left

## Documentaci√≥n del API

https://doc.rust-lang.org/
o
`rustup doc`

Click en "Standard Library API Reference"
o
`rustup doc --std`

`rustup doc --std --path` para ver la ruta local

---
class: middle, left

## Sintaxis + Conceptos en su mayor√≠a comunes con otros lenguajes

---
class: middle, left

## Comentarios

* Doble slash al inicio de una l√≠nea (`//`)
* Intenta comentar uno de las l√≠neas de impresi√≥n
* Hay otros tipos de comentarios pero este es el m√°s com√∫n

---
class: middle, left

## Variables

```rust
let name = "Ashley";
let age = 30;
println!("Hola, {}! Tienes {} a√±os de edad.", name, age);
```

* Intenta agregar m√°s variables e imprimirlas todas en un s√≥lo `println!`

???

* `let`, nombre de la variable, signo igual, valor, punto y coma.
* Pinzas de cangrejo en println, luego los valores que deben encajar ah√≠

---
class: middle, left

## Experimento

¬øQu√© pasa si ejecutas esto?

```rust
let apples = 100;
apples += 50;
println!("Tengo {} manzanas", apples);
```

???

* Haz que alguien lea el mensaje de error
* Indica que el compilador captur√≥ esto para nosotros antes de ejecutar el programa

---
class: middle, left

## Mutabilidad

Las variables son *inmutables* por defecto en Rust.

```rust
let mut apples = 100;
apples += 50;
println!("Tengo {} manzanas", apples);
```

???

* Rust tiene influencias de programaci√≥n funcional
* Cambiar un valor en donde no se esperaba es una fuente com√∫n de bugs.

---
class: middle, left

## Tipos

Rust es de tipado fuerte y est√°tico. Los tipos fundamentales son:

- `u32`: Entero de 32-bit sin signo
- `i32`: Entero de 32-bit con signo
- `f64`: N√∫mero de coma flotante
- `String` y/o `&str`: Luego lo vemos
- `bool`: Un boolean

???

* Tipado fuerte significa que la seguridad de tipos se aplica con m√°s fuerza. El compilador verifica si todos los tipos est√°n correctamente especificados la mayor parte del tiempo
* Tipo est√°tico significa que los tipos son conocidos en tiempo de compilaci√≥n. No puedes tener una variable sin saber si tipo
---
class: middle, left

## Inferencia de Tipos

* Cada valor tiene un tipo que el compilador debe conocer.
* La mayor√≠a de tiempo, el compilador puede averiguarlo.
* Algunas veces no puede, y obtendr√°s un error y deber√°s agregar una anotaci√≥n.
* Podr√≠amos haber escrito `let age: i32 = 30;`
* Un lugar en donde **debemos** especificar los tipos es en la definici√≥n de funciones.

???

* Los tipos viene despu√©s del nombre
* ¬°El compilador es tu amigo! Comprueba si te falta especificar los tipos que no puede averiguar y te dice c√≥mo corregirlo

---
class: middle, left

## Funciones

```rust
fn add_fifty(n: i32) -> i32 {
    n + 50
}

fn main() {
    println!("Porciones: {}", add_fifty(100));
}
```

???

* Argumento/par√°metro, nombrado con una tipo especificado
* `->` m√°s el tipo de retorno, si se retorna una valor
* No hay punto y coma en la √∫ltima l√≠nea cuando se retorna ese valor
* No hay `return` a menos que hagas otro `return` anteriormente
* La llamada a la funci√≥n siempre usa par√©ntesis, incluso si no hay argumentos

---
class: middle, left

## Condicionales: `if`

```rust
fn main() {
    let height = 167u32;
    if height < 150 {
        println!("Eres demasiado peque√±o para ir en la monta√±a rusa.");
    } else if height < 200 {
        println!("¬°Puedes ir en la monta√±a rusa!");
    } else {
        println!("Eres demasiado alto para ir en la monta√±a rusa.");
    }
}
```
???

* ¬°No hay par√©ntesis! Esto no es opcional
* Abreviatura de anotaci√≥n de tipo num√©rico
* La edad no puede ser negativa, el compilador se asegurar√° que no tengamos edades negativas

---
class: middle, left

## Condicionales: `match`

Como un `switch`. Pero mejor

```rust
fn main() {
    let height = 167u32;
    match height {
        0..=150 => println!("Eres demasiado peque√±o para ir en la monta√±a rusa."),
        150..=200 => println!("¬°Puedes ir en la monta√±a rusa!"),
        _ => {
            println!("Eres demasiado alto para ir en la monta√±a rusa.");
        },
    }
}
```

???

* El gui√≥n bajo atrapa a todo
* Patr√≥n, cohete, c√≥digo para ejecutar
* Comas al final de la l√≠nea del c√≥digo a ejecutar
* Si el c√≥digo es de m√°s de una l√≠nea, va entre llaves
* La coma final es estilo
* ¬øQu√© pasa si sacamos la l√≠nea del gui√≥n bajo? Esta es la ventaja del `match` sobre `if`/`else if`/`else`

---
class: middle, left

## Arrays

Como los arrays en otros lenguajes, pero peor.

```rust
let mut color = [255, 0, 255];
color[0] = 100;
println!("El color es {:?}", color);
```

???

* Los arrays tienen un tama√±o conocido en tiempo de compilaci√≥n
* Corchetes, comas
* Indexaci√≥n a una ubicaci√≥n particular
* Necesita un formato de depuraci√≥n en println ya Rust no sabe como quieres mostrar los arrays a tus usuarios
* Para el d√≠a a d√≠a, puede que no necesites arrays. No mucha gente los usa

---
class: middle, left

## Vectores

La mayor parte del tiempo, probablemente quieras un vector m√°s que un array.

```rust
let mut prices = vec![30, 100, 2];
prices[0] = 25;
prices.push(40);
println!("Todos los precios son: {:?}", prices);
```

???

* La abreviatura de la macro `vec!`, el resto es como un array
* Los vectores pueden cambiar en tama√±o en tiempo de ejecuci√≥n
* As√≠ que podemos llamar al m√©todo `push`

---
class: middle, left

## R√°pida pero √ötil Tangente #1: Formateando con `println!`

* `{}` es llamado formateo `Display`; s√≥lo en tipos primitivos por defecto
* `{:?}` es llamado formateo `Debug`; los dem√°s tipos tienen este por defecto
* Display es para usuarios finales, Debug es para... depurar
* Rust no quiere hacer suposiciones
* Mi favorito es: `{:#?}` = depuraci√≥n bonita
* [`fmt` docs](https://doc.rust-lang.org/stable/std/fmt/index.html)

---
class: middle, left

## R√°pida pero √ötil Tangente #2: `panic!`

* Panic detiene tu programa con un mensaje.

```rust
fn main() {
    panic!("aaaaa!");
}
```

--

¬øQu√© pasa en el √∫tlimo ejemplo si intentamos aceder a un elemento fuera de los l√≠mites del array?

```rust
let color = [255, 0, 255];
let index = 9;
println!("El d√©cimo elemento es {:?}", color[index]);
```

???

* Esto es un `panic!` destr√°s de escenas!
* Tiene que hacerse con seguridad ¬°No continues con malos datos!


---
class: middle, left

## Bucles (y rangos)

* Los bucles `for` son los m√°s comunes:

```rust
for i in 0..10 {
    println!("N√∫mero {}", i);
}
```

```rust
let names = vec!["Carol", "Jake", "Marylou", "Bruce"];
for name in names.iter() {
    println!("Hola {}!", name);
}
```

* Otra vez, no hay par√©ntesis
* `loop` crea un bucle infinito
* Los bucles `while` se ejecutan mientras la condici√≥n sea verdadera
* `break` termina el bucle actual

???

* Con el bucle `for` nunca iremos m√°s all√° del fin del array
* ¬øQu√© es iter? Es un tipo compartido para cosas que pueden interarse, muchos otros tipos pueden ser transformados en √©l

---
class: middle, left

## Iteratores

```rust
for i in (0..10).filter(|x| x % 2 == 0) {
    println!("i = {}", i);
}

for i in (0..10).map(|x| x * x ) {
    println!("i = {}", i);
}

let sum = (0..10).fold(0, |acc, x| acc + x);
println!("suma = {}", sum);
```

* Mira la [documentaci√≥n sobre Iterator](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html) para cosas mucho m√°s divertidas.
* El `|x| x % 2 == 0` en los ejemplos es un closure, pueden ser usados en otras situaciones tambi√©n.

???

* Un closure tambi√©n es conocido como una funci√≥n lambda, o funcion an√≥nima. Es b√°sicamente una funci√≥n que no est√° vinculada a una variable.

---
class: middle, left

## Enums

* Buenos para usar con `match`

```rust
enum TrafficLight {
    Red,
    Yellow,
    Green,
}
let light = TrafficLight::Green;

match light {
    TrafficLight::Red => println!("¬°DETENTE!"),
    TrafficLight::Yellow => println!("¬°Ve m√°s despacio!"),
    TrafficLight::Green => println!("¬°Arranca, arranca, arranca!"),
}
```

???

* El doble dos puntos es para namespacing
* ¬°Muestra advertencias!

---
class: middle, left

## Enums

* Mejor que otros lenguages: ¬°Pueden tener valores!

```rust
enum GameType {
    SinglePlayer,
    MultiPlayer(u32),
}

let game = GameType::MultiPlayer(4);

match game {
    GameType::SinglePlayer => println!("¬øQu√© tal un solitario?"),
    GameType::MultiPlayer(2) => println!("¬øQu√© tal un ajedrez?"),
    GameType::MultiPlayer(4) => println!("¬øQu√© tal un bridge?"),
    GameType::MultiPlayer(num) => {
        println!("¬øQu√© tal un juego para {} jugadores?", num)
    },
}
```

???

* Los valores son espec√≠ficos a cada variante
* Hay que definir el tipo de valor en la variante
* Destrucutra = patrones que se unen a las partes
* Destrucutra para sacar valores

---
class: middle, left

## Tests

```rust
#[derive(PartialEq, Debug)] // Necesario para comparar los valores de enum
enum TrafficLight {
    Red,
    Yellow,
    Green,
}

#[test]
fn new_person_setup() {
    let light = TrafficLight::Yellow;

    assert!(light == TrafficLight::Yellow);
    assert_eq!(light, TrafficLight::Yellow);

    assert_ne!(light, TrafficLight::Red);
}
```

- Se ejecuta con `cargo test`

???

- Los tests son funciones normales que realizan aserciones, peque√±as comprobaciones que (en su mayor√≠a) verifican que algo es igual a otra cosa
- El orden no importa en los argumentos para assert_eq/assert_ne
- Intenta escribir un test que falle y mira c√≥mo se ve el mensaje de error

---
class: middle, left

## Ignorando los tests

```rust
#[test]
#[ignore]
fn not_implemented_yet() {
    assert_eq!(true, false);
}
```

Para correr los tests ingorados de todas formas: `cargo test -- --ignored`

???

- El test tiene que compilarse, pero no tiene que pasar

---
class: middle, left

## Rustlings break!

- [github.com/rust-lang/rustlings](https://github.com/rust-lang/rustlings)
- Instrucciones en el Readme, pregunta si no hay algo que no est√© claro

???

---
class: middle, left

## Sintaxis + Conceptos particulares a Rust

---
class: middle, left

## Option

**Rust no tiene `nil`/`null`**, entonces para expresar que un valor puede ser algo o nada, Rust tiene el tipo `Option`.

Option es un enum provisto por la librer√≠a est√°ndar:

```rust
enum Option<T> {
    Some(T),
    None
}
```

???

* T es un par√°metro de tipo gen√©rico, significa que Some puede tener cualquier valor
* ¬°No m√°s m√©todos sin definir en nulo!

---
class: middle, left

## Usando Option

```rust
let mut instructors = vec!["Carol"];

let a = instructors.pop();
println!("a es {:?}", a);

let b = instructors.pop();
println!("b es {:?}", b);
```

**¬øEs seguro este c√≥digo?**

???

* Cuando sacamos el √∫ltimo elemento de un vector ¬°Puede que no haya alguno!

---
class: middle, left

## Usando Option

```rust
let a = Some("Carol");

let name = a.expect("Sin nombre presente");
println!("El nombre tiene {} bytes de longitud", name.len());
```

???

* No podemos llamar a `len` en un `Option` directamente ya que este puede ser `None`!
* Espera p√°cnico si obtienes un None, bueno para prototipar o cuando est√°s MUY SEGURO que tienes Some
    * Establece un mensaje de error en expect que te sea √∫til para depurar
    * Intenta cambiar `a` a esto y mira lo que pasa
        `let a: Option<&str> = None;`
    * Te lo menciona, pero pasa por alto el tipo de anotaci√≥n

---
class: middle, left

## Usando Option

```rust
let b: Option<&str> = Some("Carol");

match b {
    Some(name) => {
        println!("El otro nombre tiene {} bytes de longitud", name.len())
    },
    None => {
        println!("¬°Sin nombre!")
    }
}
```

???

* Match es √∫til para manejar ambos casos
* ¬°Option es s√≥lo otro enum!

---
class: middle, left

## Result

* Otro enum en la liber√≠a est√°ndar
* Para cuando algo puede fallar o tener √©xito
* Rust no tiene excepciones; usando `Result` es como manejas los errores.

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

???

---
class: middle, left

## Usando Result

```rust
let numstr = "6";
let num = numstr.parse::<i32>();
println!("num = {:?}", num);

let numstr = "florp";
let num = numstr.parse::<i32>();
println!("num = {:?}", num);
```

???

* Turbofish! Porque podr√≠amos convertirlo a diferentes tipos.

---
class: middle, left

## Usando Result

```rust
let numstr = "6";
let num = numstr.parse::<i32>();
let num = num.expect("Debe ser un n√∫mero");

println!("num + 5 = {}", num + 5);
```

---
class: middle, left

## Usando Result

```rust
let numstr = "florp";
let num = numstr.parse::<i32>();

let answer = match num {
    Ok(n) => n + 5,
    Err(_) => 0,
};
println!("La respuesta es {}", answer);
```

???

* S√≠, puede ser molesto estar forzado a pensar sobre casos de falla todo el tiempo
* Pero te ahorrar√° tiempo de depuraci√≥n despu√©s, en serio
* Hay muchos m√©todos en Option y Result para ayudar con formas comunes de manejarlos

---
class: middle, left

## El operador `?` para propagar errores

* S√≥lo puede ser usado en m√©todos/funciones que retornan un `Result`

```rust
fn add_five_to_string(s: String) ->
    Result<i32, std::num::ParseIntError> {

    let answer = s.parse::<i32>()? + 5;
    Ok(answer)
}
```

???

* Es t√≠pico tener muchas funciones que retornan `Result` y luego tienen un `match` en la capa exterior
* Quiz√°s alg√∫n d√≠a: La capacidad de usar `?` en `Option` y otros tipos, en funciones que no retornan `Result`

---
class: middle, left

## Strings: ADVERTENCIA

* Los string en Rust se sienten complicados
* Lo sentimos

???

Trabajar con strings en Rust es m√°s complicado que trabajar con strings en otros lenguajes

En realidad los string son complicados en todos los lenguajes, s√≥lo que la mayor√≠a te oculta la complejidad y toma decisiones por ti. Rust te hace ser expl√≠cito con las decisiones.

---
class: middle, left

## Dos tipos de string

### `String`

* Asignado
* Growable (puedes agregarle cosas)
* Se puede crear con:
  * `something.to_string()`
  * `String::from("contenido string")`

### `&str`

* Pronunciado como "string slice"
* Ver en los datos string almacenados en otro lugar
* Los string hardcodeados son `&str`s

???

* `String` es m√°s como un tipo `Vec`

---
class: middle, left

## Un problema com√∫n

```rust
fn fizz(num: u32) -> String {
    if num % 3 == 0 {
        "Fizz"
    } else {
        num.to_string()
    }
}
```

???

* "Fizz" aqu√≠ no es un String, es un &str
* Hay que hacer Fizz una String para corregir esto

---
class: middle, left

## String Slices

```rust
let s = String::from("Ll√°mame Ismael blah blah...");
let part = &s[0..4];

println!("La parte es '{}'", part);
```

???

* Vec<T> : &[T] :: String : &str
* Con string slices, los √≠ndices son bytes, no chars, larga historia

---
class: middle, left

## Ownership (Propiedad)

* El *propietario* de algo es quien es responsable de limpiarlo.
* Cuando los propietarios quedan fuera del alcance, Rust llama autom√°ticamente a la limpieza del c√≥digo.

```rust
fn main() {
    let v = vec![1, 2, 3];
    println!("v es v√°lido aqu√≠! {:?}", v);
}

// v aqu√≠ ya no es v√°lido!
```

???

* Indica en d√≥nde v es v√°lido y en d√≥nde v se va del alcance

---
class: middle, left

## Transfiriendo Propiedad

* Cuando pasa un argumento a una funci√≥n, la propiedad se transfiere a la funci√≥n.
* Entonces decimos que algo se ha *movido*.

```rust
fn main() {
    let v = vec![1, 2, 3];
    print_vec(v);
    print_vec(v);
}

fn print_vec(v: Vec<i32>) {
    println!("v is {:?}", v);
}
```

???

* Explica el mensaje de error
* S√≠, es raro y molesto
* No te preocupes, lo arreglaremos

---
class: middle, left

## Referencias

* Te permite pedir prestado un recurso que no tienes
* Una referencia s√≥lo es v√°lida mientras el propietatario sera v√°lido. Rust te asegura que no tengas referencias inv√°lidas *en tiempo de compilaci√≥n*.

```rust
fn main() {
    let v = vec![1, 2, 3];
    print_vec(&v);
    print_vec(&v);
}

fn print_vec(v: &Vec<i32>) {
    println!("v es {:?}", v);
}
```

???

- A menos que *quieras* que tu funci√≥n tena la propiedad de un argumento, *probablemente* tendr√°s la mayor√≠a de tus funciones tomando referencias como argumentos.

---
class: middle, left

## Referencias Mutables

* Como las variables, las referencias son inmutables por defecto, pero puedes hacerlas mutables con `mut`.
* Puedes tener muchas referencias inmutables en un √°mbito
* S√≥lo puedes tener una referencia mutable y ninguna referencia inmutable en un √°mbito

```rust
fn main() {
    let mut v = vec![1, 2, 3];
    change_vec(&mut v);
    change_vec(&mut v);
    println!("v es {:?}", v);
}

fn change_vec(v: &mut Vec<i32>) {
    v[0] *= 5;
}
```

???

* As√≠ es como har√≠as una funci√≥n que tiene permitido cambiar sus argumentos.

---
class: middle, left

## No est√°n permitido tener referencias mutables e inmutables en el mismo √°mbito.

```rust
fn main() {
    let mut v = vec![1, 2, 3];

    let f = &v[0];
    v.clear();

    println!("¬øQu√© ser√° f? {}", f);
}
```

???

* Esto no compila-- mira el error.
* ¬øEn d√≥nde est√° la referencia inmutable?
* ¬øEn d√≥nde est√° la referencia mutable?
* Otros lenguajes te dejar√≠an hacer esto y darte datos no v√°lidos.
* ¬°Vulnerabilidad de seguridad!

---
class: middle, left

## Aprendizaje adicional
### Sintaxis + Conceptos que no hemos cubierto pero que est√°n ah√≠

.pull-left[
* Lifetimes
* Tuples
* Structs
* M√©todos
* `if let`
]
.pull-right[
* FFI
* Traits
* Generics
* Macros
* Threads
* Composici√≥n sobre herencia
]

---
class: middle, left

## Recursos

* [The Rust Programming Language Book](https://doc.rust-lang.org/stable/book/)
* [Rust by Example](http://rustbyexample.com/)
* [Rust learning](https://github.com/ctjhoa/rust-learning/)
* [into_rust() screencasts](http://intorust.com/)

---
class: middle, left

## S√≥lo una cosa m√°s: Crates

![cratesio](/img/cratesio.png)

???

* Como rubygems.org, npmjs.com
* Es f√°cil agregar crates (librer√≠as) a tu proyecto
* La librer√≠a est√°ndar de Rust es peque√±a y estable
* Los crates pueden cambiar r√°pida y radicalmente independientemente de Rust
* ¬°Vamos a usar varios crates para nuestro proyecto!
